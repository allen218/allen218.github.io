<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="article">
<meta property="og:title" content="Android开发进阶——性能优化读后笔记">
<meta property="og:url" content="http://yoursite.com/2016/04/23/Android开发进阶——性能优化读后笔记/index.html">
<meta property="og:site_name" content="Allen'Notes">
<meta property="og:description">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/26.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/1.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/2.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/3.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/4.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/5.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/6.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/8.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/7.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/9.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/10.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/11.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/13.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/12.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/14.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/15.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/16.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/17.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/18.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/19.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/20.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/21.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/22.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/23.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/24.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/25.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/28.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/29.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/30.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/31.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/32.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/33.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/34.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/35.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/36.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/37.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/38.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/39.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/40.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/41.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/42.png">
<meta property="og:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/43.png">
<meta property="og:updated_time" content="2016-04-25T02:38:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android开发进阶——性能优化读后笔记">
<meta name="twitter:description">
<meta name="twitter:image" content="http://yoursite.com/uploads/img/AndroidAdvanceDevelop/4/26.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Android开发进阶——性能优化读后笔记 | Allen'Notes </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Allen'Notes</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      


      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Android开发进阶——性能优化读后笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-23T15:37:00+08:00" content="2016-04-23">
              2016-04-23
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/23/Android开发进阶——性能优化读后笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/23/Android开发进阶——性能优化读后笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="/uploads/img/AndroidAdvanceDevelop/4/26.png" alt="img1"><br><a id="more"></a></p>
<h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>最近有两周时间在忙其它的事情，还好事情已经忙完，可以再来继续写我的博客了。写博客这件事情一定要坚持，我坚信，当博客达到一定数量，不管是你的技术，还是你的表达都会有一个大的提升。好了，继续我的博客之旅。今天写的是有关<code>Android</code>性能优化及使用一些常用工具来解决性能方面的问题。让程序更优化的技术-性能优化。</p>
<h1 id="1-布局优化"><a href="#1-布局优化" class="headerlink" title="1.布局优化"></a>1.布局优化</h1><p>布局是<code>Android</code>中最重要也是最基础的部分，布局的优化是非常重要的，好的布局，能够使你的<code>App</code>更加高效、顺畅的运行。布局优化主要从<code>Include</code>、<code>merge</code>、<code>viewStub</code>关键布局的使用及<code>减少视图树层级</code>四部分来进行优化。</p>
<h2 id="1-1-Include优化"><a href="#1-1-Include优化" class="headerlink" title="1.1 Include优化"></a>1.1 Include优化</h2><p><code>Include</code>的优化主要关注的是代码结构方面的优化，可能并不能给<code>app</code>性能带来多大提升，但它可以使我们的代码更加精炼、简洁;达到代码复用的目的。<br>常用的地方就是我们每个页面都会有一个标题栏，标题栏上有返回按钮，每个页面都需要同样的显示。这个时候我们就可以抽出一个通用的标题栏，然后通过<code>include</code>导致到具体的页面。达到让多个页面使用同一标题栏来减少重复编码的效果。<br>常见的形式：<img src="/uploads/img/AndroidAdvanceDevelop/4/1.png" alt="img1">这里需要注意的地方有两个，第一个：如果<code>include</code>这里设置了<code>id</code>，那么这个<code>id</code>就会代替我们<code>layout</code>所引用的根布局的<code>id</code>在代码中使用。第二个就是这里使用的是<code>layout</code>关键字而不是<code>android:layout</code>，而后面要讲的<code>ViewStub</code>使用的是<code>android:layout</code>。<br><strong>Include原理</strong><br><code>Include</code>的原理非常简单，就是在系统解析布局xml文件时,解析到<code>include</code>标签，就将<code>include</code>包含的根布局直接添加到其父布局。我们系统里所有的xml布局都是通过<code>LayoutInflate</code>的<code>inflate</code>函数来进行解析的。而<code>inflate()</code>又调用了<code>rInflate()</code>函数来进行解析的。我们来看看<code>rInflate</code>都做了些什么吧。<img src="/uploads/img/AndroidAdvanceDevelop/4/2.png" alt="img2">在<code>rInflate()</code>方法里，对<code>include</code>标签进行了判断，然后对使用了<code>include</code>的部分通过<code>parseInclude()</code>方法来进行对<code>include</code>内的布局进行解析。<img src="/uploads/img/AndroidAdvanceDevelop/4/3.png" alt="img2">  </p>
<h2 id="1-2-Merge标签"><a href="#1-2-Merge标签" class="headerlink" title="1.2 Merge标签"></a>1.2 Merge标签</h2><p><code>merge</code>标签可以帮助我们减少布局中的视图树的层级，这是一个布局优化很好用的一个标签，通过减少视图树的层级来减少视图渲染所使用的时间，从而使<code>app</code>更加流畅。<br>在<a href="http://allen218.github.io/2016/03/27/Android开发进阶第一章—Android的构成基石读后笔记/" target="_blank" rel="external">Android构成的基石</a>这篇文章中，我们了解到，我们<code>Activity</code>其实是有一个根视图，如果我们不通过<code>setContentView</code>来设置当前<code>Activity</code>的布局，直接运行，也是能看到一个只包含标题的一个空<code>Activity</code>显示的。我们的系统默认为<code>Activity</code>设置了一个根视图，它的文件名是<code>screen_title.xml</code>文件。<img src="/uploads/img/AndroidAdvanceDevelop/4/4.png" alt="img2">看到这里，也就明白了，为什么说<code>Activity</code>默认的布局是<code>FrameLayout</code>了。 </p>
<p>现在我给一个<code>Activity</code>设置了一个简单的只包含一个按钮的布局。<img src="/uploads/img/AndroidAdvanceDevelop/4/5.png" alt="img2">此时我们通过<code>hierarchy viewer</code>来分析一下<img src="/uploads/img/AndroidAdvanceDevelop/4/6.png" alt="img2">在分析之前我先说一名题外话，怎么mac上的<code>hierarchy viewer</code>变成了这个鬼，还是因为<code>studio</code>升级到<code>2.1</code>的原因，回头我去查下资料。<br>从图上可以看出有两个重复的<code>FrameLayout</code>布局。最重要的是，去掉一个布局似乎不影响布局的展示。这时我们的<code>Merge</code>就派上用场了，<code>Merge</code>就是为了解决这种重复布局的。此时把设置给<code>Activity</code>的根布局设置成<code>Merge</code>再来看看效果。<img src="/uploads/img/AndroidAdvanceDevelop/4/8.png" alt="img2"><img src="/uploads/img/AndroidAdvanceDevelop/4/7.png" alt="img2">从图上可以看出，显示结果是一样的，而我们的视图树里就直接少了一层了。视图层级越少，就意味着系统对布局视图的渲染更快。<br><strong>Merge注意的地方</strong><br><code>Merge</code>一般使用在两个<code>Layout</code>布局，有一个布局需要添加到另一个布局时，就将要被添加的子布局的根布局设置成<code>Merge</code>(如果子view要插入父view的直接父布局和子view是一样的)，而在同一布局中是不能使用的，同一布局里，子view和父view使用相同的标签，如果把子view的标签改成<code>Merge</code>那么会改变其布局的展示。  </p>
<h2 id="1-3-ViewStub标签"><a href="#1-3-ViewStub标签" class="headerlink" title="1.3 ViewStub标签"></a>1.3 ViewStub标签</h2><p><code>ViewStub</code>也是我们在布局时，必不可少的一个用来优化布局的标签。 它的作用是将使用了<code>ViewStub</code>标签的布局，在加载布局文件时，只是添加一个标记，而不会真正的加载<code>viewStub</code>所引用的布局，直到被设置为可见或者调用<code>inflate()</code>方法，才去加载那部分的视图，达到加快布局加载速度和节约系统资源的目的。  </p>
<p><code>ViewStub</code>的使用方式和<code>include</code>很相似，都是将某个独立的布局引用到当前布局，不同的是<code>include</code>是通过<code>layout</code>属性来引用布局的，而<code>ViewStub</code>是通过<code>android:layout</code>来引用布局的。我用一个小例子来说明一下。<img src="/uploads/img/AndroidAdvanceDevelop/4/9.png" alt="img2"><img src="/uploads/img/AndroidAdvanceDevelop/4/10.png" alt="img2">上面是我通过<code>viewStub</code>设置的布局。为了验证当布局在加载过程中，被<code>ViewStub</code>引用进来的子view有没有被加载？我在<code>Activity</code>在没有设置<code>ViewStub</code>显示或者<code>inflate()</code>的时候去使用<code>findViewById</code>去找我们的子view中的<code>TextView</code>.然后为<code>TextView</code>设置文本显示。<img src="/uploads/img/AndroidAdvanceDevelop/4/11.png" alt="img2">上面是我们的设置，然后运行看看有什么结果。<img src="/uploads/img/AndroidAdvanceDevelop/4/13.png" alt="img2">这里直接就报了<code>NullPointException</code>，说明子<code>View</code>里的TextView还没有被加载到内存，系统找不到此资源。也就论证了我们前面所说的，当<code>ViewStub</code>没有被设置为可见或者<code>inflate()</code>时，被<code>ViewStub</code>引用到布局的资源是不会被加载到内存的。<img src="/uploads/img/AndroidAdvanceDevelop/4/12.png" alt="img2"><br>个人觉得<code>ViewStub</code>是对布局优化帮助很大的一个标签。对一些不需要一开始就加载的布局，使用<code>ViewStub</code>，是非常棒的一个选择。</p>
<h2 id="1-4减少视图树层级"><a href="#1-4减少视图树层级" class="headerlink" title="1.4减少视图树层级"></a>1.4减少视图树层级</h2><p>因为每一个视图都要经过测量，布局，绘制的过程，如果视图树的层级越少，就能相应的减少布局的测量、布局和绘制，从而提高<code>UI</code>的流畅度。就是在能够实现布局效果的前提下，尽量减少视图的层级。这里没什么好说的，有几点原则，大家注意一下吧。  </p>
<blockquote>
<p>1.尽量使用<code>RelativeLayout</code><br>2.在<code>ListView</code>的<code>item view</code>布局尽量不要使用<code>LinearLayout</code>的<code>weight</code>来进行布局。因为使用<code>weight</code>都会导致<code>view</code>被绘制两次。<br>3.将可以复用的布局进行抽取，通过<include>来进行引用<br>4.使用<viewstub>来对一些不常显示的布局进行优化。<br>5.使用<merge>来减少不冗余的层级</merge></viewstub></include></p>
</blockquote>
<h1 id="2-内存优化"><a href="#2-内存优化" class="headerlink" title="2.内存优化"></a>2.内存优化</h1><p>内存优化是<code>App</code>开发中非常重要的一个环节，一般<code>Android</code>系统给每个<code>App</code>分配的内存大小是有限制的，一般限制为<code>192M</code>,也就是一个应用程序的最大内存占用为<code>192M</code>，如果超出这个大小，就会导致<code>out of memory</code>内存溢出。所以做好内存优化是非常必要的。我们常用的内存优化有以下几点：</p>
<h2 id="2-1-不要滥用service"><a href="#2-1-不要滥用service" class="headerlink" title="2.1 不要滥用service"></a>2.1 不要滥用service</h2><p>如果<code>App</code>内使用了<code>Service</code>，除非它触发了一个任务，否则，其它时候它都是处于非运行状态，但由于系统对<code>Service</code>的回收策略，导致没有在运行的<code>Service</code>仍然占用着系统的内存资源，而且，当<code>Service</code>停止失败会引起内存泄漏。除非是你有经常需要在后台运行的任务需要使用到<code>Service</code>不然，不要轻易去使用它，一般推荐使用<code>IntentService</code>来代替<code>Service</code>来完成相应的任务。<code>IntentService</code>会在任务执行完成后自动去结束自己，而让其占用的资源通过GC回收。  </p>
<h2 id="2-2-当UI隐藏时释放内存"><a href="#2-2-当UI隐藏时释放内存" class="headerlink" title="2.2 当UI隐藏时释放内存"></a>2.2 当UI隐藏时释放内存</h2><p>这里说的是一个进程级别的概念，并不是单个<code>App</code>某个页面的隐藏。当我们在多个<code>App</code>之间切换时，运行在后台的<code>App</code>，在<code>Activity</code>里覆写<code>onTrimMemory</code>方法，并在这个方法里监听来自<code>TRIM_MEMORY_UI_HIDDEN</code>级别的回调。在这个级别的回调里可以做一些回收资源的操作。当<code>App</code>处于后台之后，每个覆写了<code>onTrimMemory</code>的方法都做被回调。这里的UI隐藏，不同于<code>Activity</code>里的<code>onStop</code>方法，<code>onStop</code>是当前页面级别的回调，也就是这个app还处于前台运行，而要在当前页面打开一个新的页面，使得当前当前页面不可见，而被调用此方法;而<code>onTrimMemory</code>是<code>App</code>级别的回调，也就是只有当当前<code>App</code>处于后台运行时，才会被调用此方法。</p>
<h2 id="2-3-当内存紧张时释放部分内存"><a href="#2-3-当内存紧张时释放部分内存" class="headerlink" title="2.3 当内存紧张时释放部分内存"></a>2.3 当内存紧张时释放部分内存</h2><p>这里所说的内存也是系统内存，而不是单个<code>App</code>被限制的内存上限。同样的，这里也是要在<code>Activity</code>里来监听<code>onTrimMemory</code>方法，来根据不同的级别来进行相应<code>App</code>资源的回收，以保证系统的正常稳定运行。这里的提示级别有以下几种：  </p>
<blockquote>
<p>1.TRIM_MEMORY_COMPLETE:系统内存不足，并且该进程在后台进程列表最后一个，也就是马上会被GC清理。<br>2.TRIM_MEMORY_MODERATE:系统内存不足，并且该进程在后台进程列表的中部位置<br>3.TRIM_MEMORY_BACKGROUND:系统内存不足，并且该进程是后台进程<br>4.TRIM_MEMORY_UI_HIDDEN:代表当前进程的UI已经被隐藏，也就是当前<code>App</code>已经处于后台进程。<br>5.TRIM_MEMORY_RUNNING_CRITICAL:你的app仍在运行，但是系统已经把LRU Cache中的大多数进程已经杀死，因此，必须立即释放非必须的资源，如果系统不能回收到足够的RAM大小，那么就会将<code>LRU Cache</code>列表里的所有进程杀死。<br>6.TRIM_MEMORY_RUNNING_LOW:你的app正在运行且没有被列为可杀死的。但是，设备正运行更在低内存的状态下，你应该释放一些资源。<br>7.TRIM_MEMORY_RUNNING_MODERATE:你的app正在运行且没有被列为杀死的。但是，设备正在运行在低内存状态下，系统开始触发<code>LRU Cache</code>中的<code>Process</code>回收机制。<img src="/uploads/img/AndroidAdvanceDevelop/4/14.png" alt="img2"></p>
</blockquote>
<h2 id="2-4-检查你应用使用的内存"><a href="#2-4-检查你应用使用的内存" class="headerlink" title="2.4 检查你应用使用的内存"></a>2.4 检查你应用使用的内存</h2><p>每个系统版本或者每个厂商都会根据memory的大小对<code>App</code>的内存大小限制进行设置，每个设备对单个<code>App</code>的大小限制是不太一样的。好像在6.0之前，我试过的几部手机的内存大小限制都是<code>192M</code>,而在三星<code>S6</code>上测试的内存大小限制为<code>256M</code>。可能通过<code>getMemoryClass</code>来获得当前设备所分配的单个<code>App</code>内存大小的限制。<img src="/uploads/img/AndroidAdvanceDevelop/4/15.png" alt="img2">当前为了满足有些大内存应用的操作，<code>Android</code>还是开了后门的，可以在<code>Mainfest</code>文件设置<img src="/uploads/img/AndroidAdvanceDevelop/4/16.png" alt="img2">此属性，可以让应用程序冲破内存大小的限制。具体为多大，可以通过<code>getLargeMemoryClass</code>来获得。三星<code>S6</code>的为<code>512M</code>,也就是最大内存分配比内存大小限制大了一倍。当然，除非必要，不然，不要轻易设置此参数，而应该把心思花到内存优化上。  </p>
<h2 id="2-5-避免Bitmap的浪费"><a href="#2-5-避免Bitmap的浪费" class="headerlink" title="2.5 避免Bitmap的浪费"></a>2.5 避免Bitmap的浪费</h2><p><code>Bitmap</code>占用内存的计算方法为:图片长度  <em>  图片宽度  </em>  单位像素占用的字节数。比如一张图片的分辨率为1110x568,那么它所占用的内存大小为1110x568x4，单位字节B,总共为2521920B.约2.4M。如果图片的分辨率越高所占内存越大。当图片的分辨率大于设备的分辨率时，此时，就需要对图片进行缩放处理，这里可以使用<code>BitmapFactory.Options</code>的<code>inSampleSize</code>来进行比例的缩放操作。当然在使用<code>inSampleSize</code>之前，要先使用<code>inJustDecodeBounds=true</code>来先加载图片的信息，得到相应长和宽后，再和设备的分辨率来作一个比较，最后得到比例，将比例设置给<code>inSampleSize</code>,之后，再使用<code>inJustDecodeBounds=false</code>让<code>BitmapFactory</code>去加载完整的图片。这样就成功的把图片进行了缩放，减少了图片占用内存的大小。  </p>
<h2 id="2-6-使用优化的数据容器"><a href="#2-6-使用优化的数据容器" class="headerlink" title="2.6 使用优化的数据容器"></a>2.6 使用优化的数据容器</h2><p>像我们经常使用的<code>HashMap</code>是我们<code>Java</code>下的<code>Api</code>，而它是比较消耗内存的，对此，在<code>Android FrameWork</code>提供了一些优化后的容器，比如<code>SpareArray</code>和<code>ArrayMap</code>就是<code>Android</code>下优化过的<code>HashMap</code>，使用它们可以减少存储时的内存消耗，更节省资源。</p>
<h2 id="2-7-请注意内存的开销"><a href="#2-7-请注意内存的开销" class="headerlink" title="2.7 请注意内存的开销"></a>2.7 请注意内存的开销</h2><p>这里主要说的就是在开发过程中关注一下使用的库的开销。比如：使用<code>Enums</code>的开销是使用<code>static contants</code>的2倍。每一个类(包括匿名内部类)都会使用大概500bytes。每一个类的实例产生的开销是12-16Bytes。往<code>HashMap</code>添加一个<code>entry</code>，除了数据本身的内存占用外，还会多出一个额外占用32bytes的entry对象。</p>
<h2 id="2-8-请注意代码的抽象"><a href="#2-8-请注意代码的抽象" class="headerlink" title="2.8 请注意代码的抽象"></a>2.8 请注意代码的抽象</h2><p>这里说的是，虽然抽象能够提升代码的灵活性与可维护性，但抽象也会带来一个显著的开销。通常需要同等量的代码被<code>Mapping</code>到内存中。如果你在代码里使用的抽象没有显著的提高效率，请慎用。</p>
<h2 id="2-9-为序列化数据使用nano-protobufs"><a href="#2-9-为序列化数据使用nano-protobufs" class="headerlink" title="2.9 为序列化数据使用nano protobufs"></a>2.9 为序列化数据使用nano protobufs</h2><p>这里也没有什么好说的，<code>nano protobufs</code>是一个库，它提供了对数据序列化和反序列化的支持。<code>Protobuf Nano</code>内部封装了<code>Parcelable</code>接口，也就是使用<code>Nano</code>处理过的对象是已经实现了<code>Parcelable</code>的，可以直接在Intent和进程间传递这些对象。</p>
<h2 id="2-10-尽量避免使用依赖注入框架"><a href="#2-10-尽量避免使用依赖注入框架" class="headerlink" title="2.10 尽量避免使用依赖注入框架"></a>2.10 尽量避免使用依赖注入框架</h2><p>这里所说的就是注解框架的实现是比较消耗内存的，为了搜寻代码中的注解，通常都需要花费很长的初始化过程，在这个过程中可能会把一些用不到的对象都加载到内存中，而这些用不到的对象会一直占用着内存，可能需要很长的时间才会的释放。  </p>
<h2 id="2-11-谨慎使用外部库"><a href="#2-11-谨慎使用外部库" class="headerlink" title="2.11 谨慎使用外部库"></a>2.11 谨慎使用外部库</h2><p>尽量使用一些网上比较流行的库，因为流行的库一般都是那个时候各方面优化都做得比较到位的库，或者是更新速度会比较快的，即使有问题，也就很快得到解决。还有就是不要为了一个小的功能实现去导入一个很大库，你可以选择将库里的一部分抽取出来用于功能实现或者干脆自己实现。</p>
<h2 id="2-12-优化整体性能"><a href="#2-12-优化整体性能" class="headerlink" title="2.12 优化整体性能"></a>2.12 优化整体性能</h2><p>这里主要推荐<code>Google</code>官方的两篇关于优化的文章 <a href="http://developer.android.com/training/best-performance.html" target="_blank" rel="external">Best Practices for Performance</a> 和<a href="http://developer.android.com/intl/es/tools/debugging/debugging-ui.html" target="_blank" rel="external">optimizing your UI</a></p>
<h2 id="2-13-使用ProGuard来剔除不需要的代码"><a href="#2-13-使用ProGuard来剔除不需要的代码" class="headerlink" title="2.13 使用ProGuard来剔除不需要的代码"></a>2.13 使用ProGuard来剔除不需要的代码</h2><p><code>ProGuard</code>能够通过移除不需要的代码，重命名类，域和方法等来对代码压缩、优化、和混淆。需要系统学习一下<code>ProGuard</code>的一些规则和方法。</p>
<h2 id="2-14-对最终的APK使用zipalign"><a href="#2-14-对最终的APK使用zipalign" class="headerlink" title="2.14 对最终的APK使用zipalign"></a>2.14 对最终的APK使用zipalign</h2><p>Android SDK中包含一个<code>zipalign</code>的工具，它能对打包的应用程序进行优化。我们知道APK其实就是一个<code>Zip</code>压缩文件，通过<code>Zipalign</code>优化后可以使你的app运行更快。从原理上来讲就是通过格式化<code>Zip</code>文件夹中的二进制文件的序列，达到提升系统解析速度。就像我们在阅读代码的过程中先格式化一遍代码，会让我们更容易理解其含义一样。<code>ZipAlign</code>在sdk/tool/build-tools/xxx(这里任意版本都可)/zipalign(windows 为zipalign.exe).<br><strong>使用方法</strong>  </p>
<blockquote>
<p>1.先通过命令行工具进入到<code>zipalign</code>所在目录<br>2.zipalign -v4 需要优化的apk绝对路径  优化后的apk绝对路径<br>3.优化完成后，检查优化是否成功？zipalign -c -v4 优化后的apk绝对路径</p>
</blockquote>
<h2 id="2-15-使用多进程"><a href="#2-15-使用多进程" class="headerlink" title="2.15 使用多进程"></a>2.15 使用多进程</h2><p>如果合适的话，有一个更高级的技术可以帮助你的app管理内存使用:通过把app组件切分成多个组件，运行在不同的进程中。当然这个技术必须慎用，大多数应用都不需要运行在多进程中。因为如果使用不当，会增加内存的使用，而不是减少。当你的应用程序需要在后台运行与前台一样的大量任务时，可以使用此技术。比较典型的例子就是音乐播放器。 </p>
<p>好了，到这里有关内存优化的部分就完成了，这里的优化方式，都是<code>Google</code>官方推荐的优化方式，这里只是进行一个cp然后手打而已。</p>
<h1 id="3-内存泄露"><a href="#3-内存泄露" class="headerlink" title="3.内存泄露"></a>3.内存泄露</h1><p>内存泄露就是已经执行完不需要的对象还存在于内存中，GC没有办法进行回收，造成内存被无用的对象所占用，而导致的内存浪费。这里要简单的说一下GC的回收机制。 </p>
<p><strong>GC认定可回收对象原理</strong><br>gc认定对象是否可回收，有两种方式。在<code>Java</code>早期版本中，使用的是计数器法来判定对象是否可回收，当对象被引用一次，计数器+1，而iqvv对象引用被移除相应的计数器-1，如果计数器为0，说明此对象没有被引用，就会判定为垃圾对象，标记后让gc执行回收。而这种方式有个<code>孤岛问题</code>，也就是垃圾对象之间的相互引用，这种情况gc会认为这些对象还有被使用，因为还存在被其它对象的引用。而其实这些对象只是相互被引用。<br>由于这个问题，后期的<code>Java</code>版本已经进行了修复，使用了根搜索法来判定对象是否可回收。根探索法的原理是从GC Roots(每种具体的实现对GC Roots的定义不同)作为起点，向下搜索它们的引用对象，可以生成一颗树，树的节点表示可达对象，反之视为不可达。不可达的就会被gc判定为垃圾对象，然后被GC回收。  </p>
<h2 id="3-1-Memory-Monitor"><a href="#3-1-Memory-Monitor" class="headerlink" title="3.1 Memory Monitor"></a>3.1 Memory Monitor</h2><p><code>Android Studio</code>提供的内存监控工具。<img src="/uploads/img/AndroidAdvanceDevelop/4/17.png" alt="img2">如果此处为disable的话，需要开启<code>adb Integration</code><img src="/uploads/img/AndroidAdvanceDevelop/4/18.png" alt="img2">或者重新插拔数据线。<br><img src="/uploads/img/AndroidAdvanceDevelop/4/19.png" alt="img2">图上灰色表示已分配未使用内存，而蓝色表示已分配已使用内存。这里说明一下，每个app虽说有内存大小的限制，但是并不是一次系统就把所有的内存分配给了app，而是在不断的变化中动态的去增加内存的分配，直到达到单个app内存大小的限制。  </p>
<p><strong>调试方法</strong><br>花一些时间与app进行交互，并关注内存的变化情况。<code>free</code>未使用部分的内存会慢慢变小，直到没有内存可用，这时就会触发GC，回收一些无用的对象，如果gc触发之后还是不够用，这时，就会为app增加内存。当你在短时间内发现内存的使用快速增长或者gc变得非常频繁，此时，就需要加倍小心了，很有可能已经发生了内存泄露。当然这个时候也需要有你的判断，也就是当前页面是否需要这么大的一个内存。<br>如果看到内存的占用不断增加，这时系统会为app不断的分配新的内存，直到达到单个app内存大小限制而oom。如果碰到这种情况，说明你的app在内存分配使用情况上犯了严重的错误。  </p>
<p>除了<code>Memory Monitor</code>之外，在<code>DDMS</code>工具集里还有个<code>Heap</code>的工具也可以用来观察内存的开销变化。<img src="/uploads/img/AndroidAdvanceDevelop/4/20.png" alt="img2">通过在app的操作以及手动的调用<code>Cause GC</code>来回收资源，从而来观察其相应页面的内存回收情况，以此判定是否存在内存泄露。</p>
<h2 id="2-2-Leak-Canary"><a href="#2-2-Leak-Canary" class="headerlink" title="2.2 Leak Canary"></a>2.2 Leak Canary</h2><p>这个工具，我相信大部分人都听过了的，这是一个非常好使的检查内存泄露的工具。使用起来非常简单，但是非常有用。此工具是由<code>Android</code>下的开源巨头<code>square</code>公司开源的。  </p>
<p><strong>作用</strong><br><code>LeakCanary</code>会自动完成内存追踪、检测、分析、输出结果，甚至会在<code>OOM</code>发生之前，就把内存泄露日志报告给你，避免了你手动分析内存的工作。通过会通过通知栏，或者logcat来通知用户相关的内存泄漏信息，相应的引用，哪里造成的泄露都一清二楚。</p>
<p><strong>使用方法</strong><br>先通过<code>gradle</code>导入依赖库<img src="/uploads/img/AndroidAdvanceDevelop/4/21.png" alt="img2">然后，再通过在全局<code>Application</code>的<code>onCreate</code>方法里来进行初始化工作。<img src="/uploads/img/AndroidAdvanceDevelop/4/22.png" alt="img2">此时就可以开始监听app内部的内存泄露了，如果出现内存泄露，会通过通知栏和logcat来通知你。但是这里需要注意的是，默认的它只会监听<code>Activity</code>的内存泄露。如果需要观察其它对象，需要拿到<code>RefWatcher</code>对象后，来对特定对象进行监听。<br>比如我想要监听下面的<code>info</code>对象是否会发生内存泄露<img src="/uploads/img/AndroidAdvanceDevelop/4/23.png" alt="img2">  </p>
<p><strong>LeakCanary原理</strong><br><code>LeakCanary</code>是通过API 14后在全局<code>Application</code>里增加了对<code>Activity</code>生命周期的回调来进行对<code>Activity</code>生命周期的监控的。<img src="/uploads/img/AndroidAdvanceDevelop/4/24.png" alt="img2"> 这是一个全局的回调，<code>App</code>里所有的<code>Activity</code>的相应生命周期的执行都会回调到这里。在<code>Application</code>里可以监听这个回调。默认情况下<code>LeakCanary</code>会监控所有<code>Activitys</code>的生命周期。并且在<code>Activity</code>调用<code>onDestory</code>后将此<code>Activity</code>对象添加到内存泄漏监控队列。也就是在<code>RefWatcher.watch()</code>中创建一个<code>KeyedWeakRefrence</code>到被监控的对象。接下来，在后台线程中观察这个弱引用是否被清除。将<code>Heap</code>内存<code>dump</code>到一个<code>.hprof</code>文件里并存储到手机内存里。<code>HeapAnalyzerService</code>在另外一个进程中启动，使用<code>HeapAnalyzer</code>来解析内存。通过HAHA这个项目来<code>HeapAnalayzer</code>计算出到<code>GC Roots</code>最短强引用来判断是否存在泄露，然后建立导致泄露的引用链。结果被回传到应用程序进程的<code>DisplayLeakService</code>中，然后输出log并发出通知。<br>如果是API 14也就是4.0之前，是没有<code>ActivityLifecleCallbacks</code>回调的，那么用户必须像前面监控<code>info</code>对象一相，来对<code>Activity</code>来进行手动监控。<img src="/uploads/img/AndroidAdvanceDevelop/4/25.png" alt="img2"> </p>
<h1 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4.性能优化"></a>4.性能优化</h1><h2 id="4-1过度绘制"><a href="#4-1过度绘制" class="headerlink" title="4.1过度绘制"></a>4.1过度绘制</h2><p><strong>1.问题描述</strong><br>设计出漂亮的界面只是开发过程中的一部分，还需要确保用户界面可以流畅的运行。一个常见的问题就是用户界面常常会卡顿，这里有一个可能的原因为<code>OverDraw</code>(过度绘制)。过度绘制屏幕上的某个像素在同一幀的时间内被绘制了多次。<br>比如：一个具有蓝色的背景<code>TextView</code>，它不仅会蓝色绘制用户可见的区域，而是绘制整个蓝色的背景以及<code>TextView</code>上的文字。这就导致了一些像素被会被绘制两次，这就是过度绘制。<br>当然，像上面的过度绘制是不可避免的，但是还有很多的情况是可以进行优化的。当你的<code>App</code>性能出现问题时，通常可以先从过度绘制来进行分析。<br><strong>2.检测过度绘制工具</strong><br>这里我们使用的是<code>Android</code>系统自带的开发工具<code>调度GPU过度渲染</code>将其打开，选择<code>显示过度渲染区域</code>。<img src="/uploads/img/AndroidAdvanceDevelop/4/28.png" alt="img2"> 打开之后，就可以看到<code>App</code>的每个地方都有用不同的颜色来做标识。这时的颜色分为四种，分别代表重绘的次数。<img src="/uploads/img/AndroidAdvanceDevelop/4/29.png" alt="img2"> </p>
<blockquote>
<p>1.没颜色：代表没有过度绘制<br>2.浅紫色：代表过度绘制一次。也就是同一个像素点被绘制了两次。<br>3.绿色：代表过度绘制二次，也就是同一个像素点被绘制了三次。通常，你需要集中精力优化过度绘制大于等于2次的情况。<br>4.浅红色：代表过度绘制三次，也就是同一个像素点被绘制了四次。这取决于你的应用，小范围的3次重绘可能是不可避免的，但如果大面积的出现，那说明布局设置肯定出现了问题，应该检查一下布局是否合理。<br>5.深红色：代表过度绘制四次或者更多，也就是同一像素点被绘制了五次甚至更多。出现这种问题你一定要找出原因，进行优化。</p>
</blockquote>
<p><strong>3.最小化过度绘制</strong><br>也就是说当出现过度绘制的问题时，最直接的解决方法就是打开xml文件找到过度绘制的区域，特别是不可见的<code>drawable</code>或者其它控件上的背景设置，以此来降低这些地方的过度绘制。也应该找出那些自己背景设置成白色，而父类也设置了背景为白色的情况。</p>
<h2 id="4-2-Android图形渲染"><a href="#4-2-Android图形渲染" class="headerlink" title="4.2 Android图形渲染"></a>4.2 Android图形渲染</h2><p>为了渲染每个视图，<code>Android</code>都会经历三个阶段:测量(onMeasure)、布局(onLayout)、绘制(onDraw)。花在这三个阶段的时间会<code>View</code>层级中的数量成正比，这也就意味着层级越深所花在渲染的时间就越长。<br>在视图渲染期间，每个View都要向它的父视图提供它自己的尺寸。而如果父视图发现任意一个尺寸有问题，那么它会强制所有的子视图重新进行测量。<br>即使没有发生尺寸有问题的情况，重新测量也会出现。比如：为了正确的进行布局,<code>RelativeLayout</code>通常会对它的子视图进行两次测量，而使用<code>weight</code>属性的<code>LinearLayout</code>也会对它的子视图进行两次测量。<br>测量和重新测量的代价是昂贵的，它们严重影响你的app的渲染速度。确保你的用户界面运行流畅的关键在于去掉不必要的view以及减少view的层级。<code>Android</code>为我们提供了分析view层级的工具——<code>Hierarchy Viewer</code></p>
<p><strong>Hierarchy Viewer的使用</strong> </p>
<p>通过两种方式可以打开<code>Hierarchy Viewer</code>。<img src="/uploads/img/AndroidAdvanceDevelop/4/30.png" alt="img2"> 或者使用<img src="/uploads/img/AndroidAdvanceDevelop/4/31.png" alt="img2">打开之后，见到的就是这个界面<img src="/uploads/img/AndroidAdvanceDevelop/4/32.png" alt="img2">当然，有时候进去不是并不是上面看到的界面，可以通过下面的方式找到<img src="/uploads/img/AndroidAdvanceDevelop/4/33.png" alt="img2">好了，我们先来说说上面三个部分都是显示什么的吧  </p>
<blockquote>
<p>1.Tree View:视图层级窗口，这里显示是的最全的信息，每一个节点代表一个view<br>2.Tree OverView:整个视图层级的缩略图<br>3.Layout View:当前视图层级的轮廓，也就是布局长什么样子  </p>
</blockquote>
<p>当你不确定一个view是否在UI界面中是必须元素，最简单的方法就是在<code>Tree View</code>里点击这个节点，然后在<code>Layout View</code>里看看它是怎么显示的，正常的显示是下面这个样子的。<img src="/uploads/img/AndroidAdvanceDevelop/4/34.png" alt="img2">这样子代表它在view上是有显示的。  </p>
<p><img src="/uploads/img/AndroidAdvanceDevelop/4/35.png" alt="img2">而这种显示说明当前view在视图里是没有显示的，是多余的，当然也并不是说这个视图完全没有用，只是说明当前这个页面显示时，它是没有起作用的。<br>我们可以通过<code>Hierarchy Viewer</code>来剖析每个view在不同的渲染阶段的耗时。<br><code>Hierarchy Viewer</code>默认并不会显示渲染时间。需要到<code>Tree View</code>的窗口上进行设置<img src="/uploads/img/AndroidAdvanceDevelop/4/36.png" alt="img2">设置方法是先点击需要查看时间的父view，点击选中后，再点击三个颜色的按钮，如果没有报错的话，当前view的所有子view都会显示三个小圆点。每个小圆点可以显示出不同的颜色，分别代表不同的等级。从左到右依次代表测量、布局、绘制的相应时间开销。每个小圆点都有几种颜色表示。</p>
<blockquote>
<p>1.绿色代表该<code>View</code>的渲染速度至少要快于一半以上的其它参与测试的节点。<br>2.黄色代表该view慢于50%以上的其他节点。<br>3.红色代表该View的渲染速度比其他所有参与测试的节点都慢。</p>
</blockquote>
<p><strong>真机运行Hierarchy Viewer调试不起的解决方法</strong><br>报错为<code>Unable to debug device</code>当然还有其它的错误提示，总之，就是不能正常打开调试。我的测试机为<code>S6</code>，一直都调不出来view页面。这里你需要导入一个库 ，这个库只有一个文件，解决此问题，<code>github</code>网址：<a href="https://github.com/romainguy/ViewServer" target="_blank" rel="external">点我</a>,将此库应用到项目后，就可以正常调试了。</p>
<h2 id="4-3-数据采集与分析工具——TraceView"><a href="#4-3-数据采集与分析工具——TraceView" class="headerlink" title="4.3 数据采集与分析工具——TraceView"></a>4.3 数据采集与分析工具——TraceView</h2><p><code>TraceView</code>是Android平台提供的一个专门用来数据采集和分析的工具。<code>TraceView</code>可以搭配<code>Debug</code>类或者使用<code>DDMS</code>工具来使用。<br>使用<code>Debug</code>类的方法为开发人员可以在需要调试代码的开始处使用<code>Debug.startMethodTracing()</code>来开启数据采集。在代码结束处使用<code>Debug.stopMethodTracing()</code>来停止对数据的采集。并将采集到的文件保存到/mnt/sdcard/目录下，文件名需要在<code>startMethodTracing()</code>的方法参数中进行配置。完整的使用见下图：<img src="/uploads/img/AndroidAdvanceDevelop/4/37.png" alt="img2"><br>另外一种是使用<code>DDMS</code>工具来生成采集数据文件。<img src="/uploads/img/AndroidAdvanceDevelop/4/38.png" alt="img2">打开<code>DDMS</code>工具后，app执行到需要采集数据的点，点击带小红点的按钮开始捕获数据，再次点击后结束捕获。此时TraceView会自动打开<code>Trace</code>文件。<img src="/uploads/img/AndroidAdvanceDevelop/4/39.png" alt="img2"><code>TraceView</code>面板分为上下两个面板，依次为<code>Timeline Panel</code>时间线面板和<code>Profile Panel</code>函数分析面板。而上面板又分为左面板和右面板，左面板为测试数据中所采集到的线程信息;右面板为时间线，时间线上是每个线程测试时间段内所涉及的函数调用信息。这些信息包含函数名、函数调用时间等。<br><code>TraceView</code>的函数分析面板的参数比较复杂，了解每一列的参数的意义是很关键的。  </p>
<blockquote>
<p>1.<code>Incl Cpu Time %</code>表示某函数占用的CPU执行时间(包括该函数调用其它函数的执行时间)占总执行时间的百分比<br>2.<code>Incl Cpu Time</code>表示某函数占用的CPU执行时间(包括该函数调用其它函数所执行的时间)<br>3.<code>Excl Cpu Time %</code>表示某函数占用的CPU执行时间(不含该函数调用其它函数的执行时间)占总执行时间的百分比。<br>4.<code>Excl Cpu Time</code>表示某函数占用的CPU执行时间(不含该函数调用其它函数的执行时间)<br>5.<code>Incl Real Time</code>表示某函数执行的真实时间，包括调用其它函数的执行时间，包含了CPU的等待、切换时间，因此要比<code>Incl Cpu Time</code>要大。<br>6.<code>Excl Real Time</code>表示某函数执行的真实时间，不含该函数调用的其它函数的执行时间<br>7.<code>Calls+Recur Calls/Total</code>表示某函数被调用的次数,递归调用次数、总调用次数<br>8.<code>Cpu Time/Call</code>表示某函数的CPU执行时间与调用次数的比，相当于该函数的平均执行时间，这里没有包含函数内部调用其它函数的执行时间<br>9.<code>Real Time/Call</code>表示某函数的CPU执行时间与调用次数的比，相当于该函数的平均执行时间，这个时间中包含了内部调用的其他函数的执行时间。  </p>
</blockquote>
<p>清楚了每列参数代表的意思之后，我们上一个例子来简单分析一下。假设我们收集的数据总共执行时间为100秒，下面的<code>request()</code>函数执行了10秒，在<code>request()</code>里有两个函数,<code>getParams()</code>和<code>excute()</code> 分别执行时间为4秒、5秒。<img src="/uploads/img/AndroidAdvanceDevelop/4/40.png" alt="img2">由于<code>request</code>的耗时为10秒，假设<code>request</code>被调用了一次，而我们收集数据的执行时间为100秒。那么<code>request</code>的<code>Incl Cpu Time</code>为10秒,<code>Incl Cpu Time %</code>就是10%。<code>Excl Cpu Time</code>是不包含函数调用其它函数的执行时间，在<code>request</code>里除去<code>getParams()</code>5秒、<code>excute()</code>4秒后，为1秒。也就是说<code>request</code>本身耗时较少，真正耗时的是它内部调用的函数。<br>接下来来一个更加具体的例子来进一步说明<img src="/uploads/img/AndroidAdvanceDevelop/4/41.png" alt="img2">我们使用<code>getView</code>来模拟一个耗时的操作。<img src="/uploads/img/AndroidAdvanceDevelop/4/42.png" alt="img2">因为我们调试的是<code>ListView</code>，而<code>ListView</code>的性能瓶颈一般会在<code>Adapter</code>的<code>getView</code>里。所以我直接在<code>Trace</code>文件中找到<code>getView</code>方法来进行分析。<code>incl Cpu Time</code>表示<code>getView</code>的执行时间，包括调用其它函数的执行时间，但是这里不包含CPU等待，切换所花费的时间，这里为135.6毫秒。<code>Incl Real Time</code>表示当前函数执行时间，包括调用其它函数的执行时间和CPU切换、等待的执行时间，这里为1485毫秒。因为我们这里主要是使用<code>Sleep</code>来进行耗时操作的，所以能看到<code>Incl Cpu Time</code>耗时比较少，而<code>Incl Real Time</code>耗时比较大。我们再来看看在<code>getView</code>内部调用的各函数所花费的时间。<code>doSomeStr</code>下的<code>Incl Real Time</code>为1383毫秒，占真实耗时的93%之多，而<code>Call + Recul Calls/Total</code>的值为75，也就是被调用了75次，其<code>Real Time/Call</code>为18.444秒，刚好就是我们使用<code>Thread.Sleep</code>所耗费的时间18毫秒，再加上一点调用相应函数所耗费的时间0.444毫秒。我们再来看看<code>doSomeStr</code>里调用的相应函数的耗时情况。<img src="/uploads/img/AndroidAdvanceDevelop/4/43.png" alt="img2">从图上可以看出，<code>Incl Real Time</code>的值分别为310、310、762，而我们在函数里让CPU的睡眠时间分别为4、4、10，比例差不多就是一样的，这里加上一丁点的函数本身执行所耗费的时间。这样，我们就找到了在<code>getView</code>里真正耗时的地方了。找到了地方就可以开始着手进行相关的优化了。  </p>
<p>好了，今天的博客终于是写完了，内容有点多，话说花了我两天的时间才写完的。写得不对的地方，还请大神多多指教！拜了个拜~</p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/21/浅谈代码重构的重要性和方法/" rel="next" title="浅谈代码重构的重要性和方法">
                <i class="fa fa-chevron-left"></i> 浅谈代码重构的重要性和方法
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/04/26/Android开发进阶——Git版本控制/" rel="prev" title="Android开发进阶——Git版本控制读后笔记">
                Android开发进阶——Git版本控制读后笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/04/23/Android开发进阶——性能优化读后笔记/"
           data-title="Android开发进阶——性能优化读后笔记" data-url="http://yoursite.com/2016/04/23/Android开发进阶——性能优化读后笔记/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/img/a21.jpg"
               alt="allen wong" />
          <p class="site-author-name" itemprop="name">allen wong</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/allen218" target="_blank">
                  
                    <i class="fa fa-globe"></i> github
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/allen-wang-74-17" target="_blank">
                  
                    <i class="fa fa-globe"></i> zhihu
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前提"><span class="nav-text">前提</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-布局优化"><span class="nav-text">1.布局优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Include优化"><span class="nav-text">1.1 Include优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Merge标签"><span class="nav-text">1.2 Merge标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-ViewStub标签"><span class="nav-text">1.3 ViewStub标签</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4减少视图树层级"><span class="nav-text">1.4减少视图树层级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-内存优化"><span class="nav-text">2.内存优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-不要滥用service"><span class="nav-text">2.1 不要滥用service</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-当UI隐藏时释放内存"><span class="nav-text">2.2 当UI隐藏时释放内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-当内存紧张时释放部分内存"><span class="nav-text">2.3 当内存紧张时释放部分内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-检查你应用使用的内存"><span class="nav-text">2.4 检查你应用使用的内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-避免Bitmap的浪费"><span class="nav-text">2.5 避免Bitmap的浪费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-6-使用优化的数据容器"><span class="nav-text">2.6 使用优化的数据容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-7-请注意内存的开销"><span class="nav-text">2.7 请注意内存的开销</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-8-请注意代码的抽象"><span class="nav-text">2.8 请注意代码的抽象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-9-为序列化数据使用nano-protobufs"><span class="nav-text">2.9 为序列化数据使用nano protobufs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-10-尽量避免使用依赖注入框架"><span class="nav-text">2.10 尽量避免使用依赖注入框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-11-谨慎使用外部库"><span class="nav-text">2.11 谨慎使用外部库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-12-优化整体性能"><span class="nav-text">2.12 优化整体性能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-13-使用ProGuard来剔除不需要的代码"><span class="nav-text">2.13 使用ProGuard来剔除不需要的代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-14-对最终的APK使用zipalign"><span class="nav-text">2.14 对最终的APK使用zipalign</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-15-使用多进程"><span class="nav-text">2.15 使用多进程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-内存泄露"><span class="nav-text">3.内存泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Memory-Monitor"><span class="nav-text">3.1 Memory Monitor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Leak-Canary"><span class="nav-text">2.2 Leak Canary</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-性能优化"><span class="nav-text">4.性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1过度绘制"><span class="nav-text">4.1过度绘制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Android图形渲染"><span class="nav-text">4.2 Android图形渲染</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-数据采集与分析工具——TraceView"><span class="nav-text">4.3 数据采集与分析工具——TraceView</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">allen wong</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.scheme !== 'Pisces' && (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always')) {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"allen218"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  
  


</body>
</html>
